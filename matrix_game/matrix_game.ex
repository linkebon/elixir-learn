# Matrix game
# Play creating a matrix by defining amount of rows and columns the game field should have
# Then each player removes values by providing a number on the game field.
# The player that removes the last element loose before the game field.

# Game field generated by 9 rows and 9 columns below.
#Game field
#---------------
#11 12 13 14 15 16 17 18 19
#21 22 23 24 25 26 27 28 29
#31 32 33 34 35 36 37 38 39
#41 42 43 44 45 46 47 48 49
#51 52 53 54 55 56 57 58 59
#61 62 63 64 65 66 67 68 69
#71 72 73 74 75 76 77 78 79
#81 82 83 84 85 86 87 88 89
#91 92 93 94 95 96 97 98 99
#---------------
defmodule Game_Logic do
  def generate_new_game_field(game_field, current_player, remove_val), do:
    Enum.map(
      game_field,
      fn row -> Enum.map(
                  row,
                  fn current_val -> if(should_value_be_removed?(current_val, remove_val)) do
                                      -1
                                    else
                                      current_val
                                    end
                  end
                )
      end
    )

  def read_remove_val(game_field) do
    case IO.gets("Print number to remove: ")
         |> String.trim()
         |> Integer.parse() do
      {parsed, _} ->
        if(number_exist_in_game_field?(game_field, parsed)) do
          parsed
        else
          IO.puts("Number did not exist in game field.. Try again \n")
          read_remove_val(game_field)
        end
      :error ->
        IO.puts("You did not provide a number.. Try again \n")
        read_remove_val(game_field)
    end
  end

  def which_players_turn?(current_player) do
    case current_player do
      "Player 1" -> "Player 2"
      "Player 2" -> "Player 1"
      _ -> "Player 1"
    end
  end

  def generate_game_field(rows, columns),
      do: for(
        row <- 0..(rows - 1),
        do: Enum.to_list(first_value_in_row(row)..last_value_in_row(row, columns))
      )

  def game_over?(game_field),
      do: Enum.all?(
        game_field,
        fn row ->
          Enum.all?(
            row,
            fn val -> val == -1 end
          )
        end
      )

  def game_field_as_string(game_field) do
    game_field_str = Enum.map(
                       game_field,
                       fn (row) ->
                         Enum.join(row, " ")
                         |> String.replace("-1", " ")
                       end
                     )
                     |> Enum.join("\n")
    "\nGame field \n---------------\n" <> game_field_str <> "\n---------------\n"
  end

  defp number_exist_in_game_field?(game_field, number),
       do: game_field
           |> Enum.any?(fn row -> number in row end)

  defp should_value_be_removed?(current_val, remove_val) do
    current_val_row = getRow(current_val)
    current_val_col = getCol(current_val)
    remove_val_row = getRow(remove_val)
    remove_val_col = getCol(remove_val)

    case current_val do
      x when current_val_row == remove_val_row and x >= remove_val -> true
      x when remove_val_row < current_val_row
             and current_val_col >= remove_val_col
             and x >= remove_val -> true
      _ -> false
    end
  end

  defp first_value_in_row(n), do: ((n + 1) * 10) + 1

  defp last_value_in_row(current_row, columns), do: first_value_in_row(current_row) + columns - 1

  defp getRow(val), do: div(val, 10) - 1

  defp getCol(val), do: rem(val, 10)

end

# https://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html
defmodule Server do
  require Logger

  def accept(port) do
    {:ok, socket} =
      :gen_tcp.listen(port, [:binary, packet: :line, active: false, reuseaddr: true])
    Logger.info("Accepting connections on port #{port}")
    loop_acceptor(socket)
  end

  defp loop_acceptor(socket) do
    {:ok, client1} = :gen_tcp.accept(socket)
    {:ok, client2} = :gen_tcp.accept(socket)
    initiate_game(client1, client2)
  end

  defp initiate_game(socket_p1, socket_p2) do
    write_to_clients("Welcome to Matrix game!", socket_p1, socket_p2)
    game_field = Game_Logic.generate_game_field(9, 9)
    write_line(Game_Logic.game_field_as_string(game_field), socket_p1)
    new_turn(game_field, socket_p1)
  end

  defp new_turn(game_field, socket_p1, player \\ "none") do
    current_player = case player do
      "none" -> Game_Logic.which_players_turn?(player)
      _ -> player
    end

    write_line("\n#{current_player}'s turn. \nEnter number to remove: ", socket_p1)
    remove_val = read_int_from_client(socket_p1)
    new_game_field = Game_Logic.generate_new_game_field(game_field, current_player, remove_val)
    #write game field to players
    write_line(Game_Logic.game_field_as_string(new_game_field), socket_p1)
    game_over?(new_game_field, current_player, socket_p1)
  end

  defp which_players_turn?(current_player) do
    #todo
    current_player
  end

  defp game_over?(game_field, current_player, socket_p1) do
    if(Game_Logic.game_over?(game_field)) do
      write_line(
        "Game over! #{Game_Logic.which_players_turn?(current_player)} WON!!! \n#{
          current_player
        } took the last element and therefore lost!",
        socket_p1
      )
    else
      write_line(Game_Logic.game_field_as_string(game_field), socket_p1)
      next_player = Game_Logic.which_players_turn?(current_player)
      write_line("#{next_player}'s turn!", socket_p1)
      new_turn(game_field, socket_p1, Game_Logic.which_players_turn?(current_player))
    end
  end

  defp read_int_from_client(socket),
       do: read_line(socket)
           |> String.trim()
           |> String.to_integer()

  defp read_line(socket) do
    {:ok, data} = :gen_tcp.recv(socket, 0)
    data
  end

  defp write_to_clients(line, socket_p1, socket_p2) do
    write_line(line, socket_p1)
    write_line(line, socket_p2)
  end

  defp write_line(line, socket) do
    :gen_tcp.send(socket, line)
  end
end
