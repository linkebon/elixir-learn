# Matrix game
# Play creating a matrix by defining amount of rows and columns the game field should have
# Then each player removes values by providing a number on the game field.
# The player that removes the last element loose before the game field.

# Game field generated by 9 rows and 9 columns below.
#Game field
#---------------
#11 12 13 14 15 16 17 18 19
#21 22 23 24 25 26 27 28 29
#31 32 33 34 35 36 37 38 39
#41 42 43 44 45 46 47 48 49
#51 52 53 54 55 56 57 58 59
#61 62 63 64 65 66 67 68 69
#71 72 73 74 75 76 77 78 79
#81 82 83 84 85 86 87 88 89
#91 92 93 94 95 96 97 98 99
#---------------
defmodule Game_Logic do
  def generate_new_game_field(game_field, current_player, remove_val), do:
    Enum.map(
      game_field,
      fn row -> Enum.map(
                  row,
                  fn current_val -> if(should_value_be_removed?(current_val, remove_val)) do
                                      -1
                                    else
                                      current_val
                                    end
                  end
                )
      end
    )

  def read_remove_val(game_field) do
    case IO.gets("Print number to remove: ")
         |> String.trim()
         |> Integer.parse() do
      {parsed, _} ->
        if(number_exist_in_game_field?(game_field, parsed)) do
          parsed
        else
          IO.puts("Number did not exist in game field.. Try again \n")
          read_remove_val(game_field)
        end
      :error ->
        IO.puts("You did not provide a number.. Try again \n")
        read_remove_val(game_field)
    end
  end

  def generate_game_field(rows, columns),
      do: for(
        row <- 0..(rows - 1),
        do: Enum.to_list(first_value_in_row(row)..last_value_in_row(row, columns))
      )

  def game_over?(game_field),
      do: Enum.all?(
        game_field,
        fn row ->
          Enum.all?(
            row,
            fn val -> val == -1 end
          )
        end
      )

  def game_field_as_string(game_field) do
    game_field_str = Enum.map(
                       game_field,
                       fn (row) ->
                         Enum.join(row, " ")
                         |> String.replace("-1", " ")
                       end
                     )
                     |> Enum.join("\n")
    "\nGame field \n---------------\n" <> game_field_str <> "\n---------------\n"
  end

  defp number_exist_in_game_field?(game_field, number),
       do: game_field
           |> Enum.any?(fn row -> number in row end)

  defp should_value_be_removed?(current_val, remove_val) do
    current_val_row = getRow(current_val)
    current_val_col = getCol(current_val)
    remove_val_row = getRow(remove_val)
    remove_val_col = getCol(remove_val)

    case current_val do
      x when current_val_row == remove_val_row and x >= remove_val -> true
      x when remove_val_row < current_val_row
             and current_val_col >= remove_val_col
             and x >= remove_val -> true
      _ -> false
    end
  end

  defp first_value_in_row(n), do: ((n + 1) * 10) + 1

  defp last_value_in_row(current_row, columns), do: first_value_in_row(current_row) + columns - 1

  defp getRow(val), do: div(val, 10) - 1

  defp getCol(val), do: rem(val, 10)

end

# https://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html
defmodule Server do
  require Logger

  def accept(port_player1, port_player2) do
    {:ok, socket_p1} =
      :gen_tcp.listen(port_player1, [:binary, packet: :line, active: false, reuseaddr: true])
    Logger.info("Accepting connections on port #{port_player1}")
    {:ok, socket_p2} =
      :gen_tcp.listen(port_player2, [:binary, packet: :line, active: false, reuseaddr: true])
    Logger.info("Accepting connections on port #{port_player2}")
    loop_acceptor(socket_p1, socket_p2)
  end

  defp loop_acceptor(socket_p1, socket_p2) do
    {:ok, client1} = :gen_tcp.accept(socket_p1)
    Logger.info("Player 1 connected")
    write_line("Welcome! Waiting for another player..", client1)
    {:ok, client2} = :gen_tcp.accept(socket_p2)
    Logger.info("Player 2 connected")
    initiate_game(client1, client2)
  end

  defp initiate_game(socket_p1, socket_p2) do
    player1 = {:player1, socket_p1}
    player2 = {:player2, socket_p2}
    write_to_clients("\n\nWelcome to Matrix game!", player1, player2)
    game_field = Game_Logic.generate_game_field(9, 9)
    write_to_clients(Game_Logic.game_field_as_string(game_field), player1, player2)
    current_player = which_players_turn?(player1, player2)
    new_turn(game_field, current_player, player1, player2)
  end

  defp new_turn(game_field, current_player, player1, player2) do
    write_to_clients("\n#{player_atom_str(current_player)}'s turn. ", player1, player2)
    write_line("Please wait.... \n", elem(other_players_turn(current_player, player1, player2), 1))
    write_line("Enter number to remove: ", elem(current_player, 1))
    remove_val = read_int_from_client(elem(current_player, 1))
    new_game_field = Game_Logic.generate_new_game_field(game_field, current_player, remove_val)
    write_line(
      "Other player removed number: #{remove_val}\n\n",
      elem(other_players_turn(current_player, player1, player2), 1)
    )
    write_to_clients(Game_Logic.game_field_as_string(new_game_field), player1, player2)
    game_over?(new_game_field, current_player, player1, player2)
  end

  defp player_atom_str(player), do: Atom.to_string(elem(player, 0))

  defp other_players_turn(current_player, player1, player2) do
    case elem(current_player, 0) do
      :player1 -> player2
      :player2 -> player1
    end
  end

  defp which_players_turn?(player1, player2, current_player \\ nil) do
    case current_player do
      nil -> player1
      _ ->
        if(elem(current_player, 0) == :player1) do
          player2
        else
          player1
        end
    end
  end

  defp game_over?(game_field, current_player, player1, player2) do
    if(Game_Logic.game_over?(game_field)) do
      write_line("You won!!! Congratulations!", elem(other_players_turn(current_player, player1, player2), 1))
      write_line("You lost.. You took the last element and therefore you lost!", elem(current_player, 1))
    else
      write_to_clients(Game_Logic.game_field_as_string(game_field), player1, player2)
      next_player = which_players_turn?(player1, player2, current_player)
      write_to_clients("#{player_atom_str(next_player)}'s turn! \n", player1, player2)
      new_turn(game_field, current_player, player1, player2)
    end
  end

  defp read_int_from_client(socket),
       do: read_line(socket)
           |> String.trim()
           |> String.to_integer()

  defp read_line(socket) do
    {:ok, data} = :gen_tcp.recv(socket, 0)
    data
  end

  defp write_to_clients(line, player1, player2) do
    write_line(line, elem(player1, 1))
    write_line(line, elem(player2, 1))
  end

  defp write_line(line, socket) do
    :gen_tcp.send(socket, line)
  end
end
